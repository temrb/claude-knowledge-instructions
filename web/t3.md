# Next.js Project Architecture & Best Practices Guide

This comprehensive guide provides detailed instructions for maintaining a consistent, scalable architecture in your Next.js application, incorporating shadcn/ui components, tRPC, Zustand state management, and Prisma for data access.

## 1. Project Root Structure

```txt
/src
  ├── /__tests__               # Centralized tests directory
  │    ├── /[feature]          # Tests organized by feature
  │    │    ├── /_snapshots_   # Snapshot test outputs
  │    │    ├── snapshot.tsx   # Snapshot test definitions
  │    │    └── [feature].test.tsx  # Unit/integration tests
  ├── /app                     # App Router components
  ├── /components              # Reusable UI components
  ├── /pages                   # Organized page components
  │    ├── /(candidate)        # Route group for candidate features
  │    ├── /settings           # Settings pages
  │    └── /u                  # User-related pages
  ├── /modals                  # Modal components by feature
  ├── /lib                     # Core utilities and validators
  │    └── /validators         # Zod validation schemas
  ├── /server                  # Server-side code
  │    └── /api                # API layer
  │         └── /routers       # tRPC router definitions
  ├── /ui                      # UI components (shadcn/ui)
  ├── /zustand                 # State management
  │    └── /features           # Feature-specific state slices
  ├── /hooks                   # Custom React hooks
  ├── /providers               # Context providers
  ├── /prisma                  # Database schema and migrations
  ├── /styles                  # Global styles
  ├── /trpc                    # tRPC client setup
  ├── /config                  # Configuration files
  ├── /constants               # Application constants
  ├── /scripts                 # Utility scripts
  ├── /layouts                 # Layout components
  └── middleware.ts            # Next.js middleware
```

## 2. Test-Driven Development Workflow

This project follows a test-driven development (TDD) approach with a centralized testing strategy:

### For New Features

1. **Write Tests First**: Begin by creating comprehensive tests in the `__tests__` directory that define the expected behavior of the feature.
2. **Implement the Feature**: Develop the feature to make the tests pass.
3. **Create Snapshots**: Generate snapshot tests to capture and verify UI rendering.
4. **Refactor**: Improve the implementation while ensuring tests continue to pass.

### For Existing Features

1. **Check Existing Tests**: Review current test coverage in the `__tests__` directory for the feature.
2. **Update Tests**: Modify tests to reflect new requirements or behaviors.
3. **Update Snapshots**: Verify and update snapshots if UI changes are expected.
4. **Implement Changes**: Modify the feature guided by the updated tests.

### TDD Cycle

1. **Red**: Write a failing test that defines the required functionality.
2. **Green**: Implement the minimum code necessary to make the test pass.
3. **Refactor**: Clean up the implementation while maintaining passing tests.

## 2. TypeScript Best Practices

Strong typing is a core principle of this project. Always follow these guidelines to maintain type safety:

### Avoiding `any`

Never use the `any` type as it undermines TypeScript's type safety. Instead:

- Use appropriate specific types for variables, parameters, and return types
- Use TypeScript's utility types like `Partial<T>`, `Pick<T>`, `Omit<T>`, etc.
- For truly unknown types, use `unknown` instead of `any`
- When accessing external APIs with uncertain structures, define interfaces based on expected response shapes

### Type Definition Patterns

```typescript
// Define explicit interfaces for data structures
interface User {
  id: string;
  name: string;
  email: string;
  role: UserRole;
  createdAt: Date;
}

// Use enums for predefined values
enum UserRole {
  Admin = 'ADMIN',
  Member = 'MEMBER',
  Guest = 'GUEST',
}

// Type component props
interface ButtonProps {
  variant?: 'default' | 'destructive' | 'outline' | 'secondary' | 'ghost' | 'link';
  size?: 'default' | 'sm' | 'lg' | 'icon';
  children: React.ReactNode;
  onClick?: (event: React.MouseEvent<HTMLButtonElement>) => void;
  disabled?: boolean;
  className?: string;
}

// Function with explicit parameter and return types
function formatUser(user: User): string {
  return `${user.name} (${user.email})`;
}
```

### Handling Unknown Types

When dealing with external data or library functions that don't provide type information:

```typescript
// Use type assertions with caution
function processApiResponse(response: unknown): User {
  // Validate the shape before treating as User
  if (
    typeof response === 'object' &&
    response !== null &&
    'id' in response &&
    'name' in response &&
    'email' in response
  ) {
    return response as User;
  }
  throw new Error('Invalid user data');
}

// Better: Use Zod for runtime validation
import { z } from 'zod';

const UserSchema = z.object({
  id: z.string(),
  name: z.string(),
  email: z.string().email(),
  role: z.nativeEnum(UserRole),
  createdAt: z.date()
});

function processApiResponse(response: unknown): User {
  return UserSchema.parse(response);
}
```

### Function Types

Define explicit return types for functions to ensure consistency:

```typescript
// Function type with explicit parameter and return types
type FetchUserFn = (userId: string) => Promise<User>;

// Event handler types
type SubmitHandler<T> = (values: T) => Promise<void>;
type ChangeHandler = (event: React.ChangeEvent<HTMLInputElement>) => void;
```

## 4. Testing Strategy

Tests are organized in a dedicated `__tests__` directory mirroring the feature structure of the application:

```txt
/__tests__
  ├── /job-search              # Tests for job-search feature
  │    ├── /advanced-job-search
  │    │    ├── /_snapshots_   # Snapshot outputs
  │    │    ├── snapshot.tsx   # Snapshot test definitions
  │    │    └── advanced-job-search.test.tsx  # Unit/integration tests
  │    └── /tailored-outreach
  │         ├── /_snapshots_
  │         ├── snapshot.tsx
  │         └── tailored-outreach.test.tsx
  ├── /components              # Tests for shared components
  │    └── /ui
  │         ├── /_snapshots_
  │         ├── snapshot.tsx
  │         └── button.test.tsx
  ├── /modals                  # Tests for modals
  │    └── /feed
  │         └── /create-feed-post
  │              ├── /_snapshots_
  │              ├── snapshot.tsx
  │              └── create-feed-post.test.tsx
  └── /server                  # Tests for server-side code
       └── /api
            └── /routers
                 └── /feed
                      └── post.test.ts
```

### Unit and Integration Test Pattern

```typescript
// File: /__tests__/components/ui/button.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import { Button } from '@/components/ui/button';

describe('Button', () => {
  it('renders correctly', () => {
    render(<Button>Click me</Button>);
    expect(screen.getByRole('button', { name: /click me/i })).toBeInTheDocument();
  });

  it('calls onClick handler when clicked', () => {
    const onClickMock = jest.fn();
    render(<Button onClick={onClickMock}>Click me</Button>);
    fireEvent.click(screen.getByRole('button', { name: /click me/i }));
    expect(onClickMock).toHaveBeenCalledTimes(1);
  });
});
```

### Snapshot Test Pattern

```typescript
// File: /__tests__/components/ui/snapshot.tsx
import { render } from '@testing-library/react';
import { Button } from '@/components/ui/button';

describe('Button Snapshots', () => {
  it('renders default button correctly', () => {
    const { container } = render(<Button>Default Button</Button>);
    expect(container).toMatchSnapshot();
  });

  it('renders destructive button correctly', () => {
    const { container } = render(<Button variant="destructive">Delete</Button>);
    expect(container).toMatchSnapshot();
  });

  it('renders disabled button correctly', () => {
    const { container } = render(<Button disabled>Disabled</Button>);
    expect(container).toMatchSnapshot();
  });
});
```

### API Test Pattern

```typescript
// File: /__tests__/server/api/routers/feed/post.test.ts
import { createInnerTRPCContext } from '@/server/api/trpc';
import { appRouter } from '@/server/api/routers';
import { mockDeep } from 'jest-mock-extended';
import { PrismaClient } from '@prisma/client';
import { Session } from 'next-auth';

// Create mocks
const prismaMock = mockDeep<PrismaClient>();
const sessionMock = {
  user: { id: 'user-123', name: 'Test User' },
  expires: new Date().toISOString(),
} as Session;

// Create test caller
const createCaller = (session: Session | null = null) => {
  const ctx = createInnerTRPCContext({
    session,
    db: prismaMock,
  });
  return appRouter.createCaller(ctx);
};

describe('Post Router', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('createPost', () => {
    it('creates a post successfully', async () => {
      // Test implementation
    });
  });
});
```

## 5. Page Structure Conventions

Pages are organized by feature and follow a consistent pattern with entry and render files:

```txt
/pages
  └── /(route-group)
       └── /feature-name
            ├── entry.tsx       # Entry point with data fetching
            └── render.tsx      # Component rendering logic
```

**Entry File Pattern (`entry.tsx`):**

- Handles data fetching and initial state
- Sets up error boundaries
- Provides data to the render component

**Render File Pattern (`render.tsx`):**

- Pure presentation logic
- Receives props from entry component
- Focused on rendering UI elements

## 6. Form Component Convention

Forms are organized by feature with a `.form.tsx` suffix:

```txt
/pages/(candidate)/profile/sections/general-info/profile-general-info.form.tsx
/modals/feed/create-feed-post/create-feed-post.form.tsx
```

**Form Component Structure:**

```typescript
// File: /modals/feed/create-feed-post/create-feed-post.form.tsx
'use client';

// 1. Imports
import { Form, FormField, ... } from '@/components/ui/form';
import { CreatePostFormSchema } from '@/lib/validators/feed/posts.z';
import { api } from '@/trpc/react';
import { feedSlice } from '@/zustand/features/feed/feedSlice';
import { modalSlice } from '@/zustand/features/ui/modalSlice';

// 2. Component
const CreateFeedPostForm = () => {
  // State management
  const { setActiveModal } = modalSlice();
  const { category } = feedSlice();

  // Form setup with react-hook-form and zod
  const form = useForm<z.infer<typeof CreatePostFormSchema>>({
    resolver: zodResolver(CreatePostFormSchema),
    defaultValues: {
      // Default values
    },
  });

  // API mutation
  const { isPending, mutateAsync } = api.feed.postRouter.createPost.useMutation();

  // Submit handler
  const onSubmit = async (values: z.infer<typeof CreatePostFormSchema>) => {
    try {
      // Form submission logic
    } catch (error) {
      // Error handling
    }
  };

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="...">
        {/* Form fields */}
      </form>
    </Form>
  );
};

export default CreateFeedPostForm;
```

## 7. API Layer with tRPC

The tRPC implementation follows a hierarchical structure under `/server/api/routers/`:

```txt
/server
  └── /api
       ├── /routers
       │    ├── /feed
       │    │    ├── index.ts          # Combines feed routers
       │    │    ├── post.ts           # Post-related routes
       │    │    └── comments.ts       # Comment-related routes
       │    ├── /track
       │    │    ├── index.ts          # Combines track routers
       │    │    ├── tracker.ts        # Job tracking routes
       │    │    └── visualize.ts      # Visualization routes
       │    └── index.ts               # Root router
       ├── /errors.ts                  # Error handling utilities
       ├── /trpc.ts                    # tRPC configuration
       └── /db.ts                      # Database client
```

**Router Structure Pattern:**

```typescript
// File: /server/api/routers/feed/index.ts
import { createTRPCRouter } from '../../trpc';
import { commentsRouter } from './comments';
import { postRouter } from './post';

export const feedRouter = createTRPCRouter({
  postRouter,
  commentsRouter,
});
```

**Individual Router Pattern:**

```typescript
// File: /server/api/routers/feed/post.ts
import {
  createTRPCRouter,
  protectedProcedure,
  publicProcedure,
} from '../../trpc';
import { throwInternalError, throwNotFound } from '../../errors';

// Define procedures
const createPost = protectedProcedure
  .input(CreatePostFormSchema)
  .mutation(async ({ ctx, input }) => {
    try {
      // Implementation
    } catch (error) {
      process.env.NODE_ENV === 'development' &&
        console.error('Error creating post:', error);
      throwInternalError('Error creating post');
    }
  });

// Export the combined router
export const postRouter = createTRPCRouter({
  createPost,
  // Additional procedures
});
```

## 8. Error Handling Pattern

Standardized error handling with specialized error functions:

```typescript
// In your API routes
try {
  // Operation logic
} catch (error) {
  process.env.NODE_ENV === 'development' &&
    console.error('Error operation description:', error);
  throwInternalError('Error message for user');
}
```

**Error Types:**

- `throwInternalError`: For server errors (500)
- `throwNotFound`: For resource not found errors (404)
- `throwForbidden`: For permission errors (403)
- `throwUnauthorized`: For authentication errors (401)
- `throwBadRequest`: For invalid request errors (400)
- `throwConflict`: For resource conflict errors (409)
- `throwParseError`: For request parsing errors
- `throwMethodNotSupported`: For unsupported HTTP methods (405)
- `throwTimeout`: For request timeout errors (408)
- `throwPreconditionFailed`: For precondition failures (412)
- `throwPayloadTooLarge`: For request entity too large (413)
- `throwUnsupportedMediaType`: For unsupported media types (415)
- `throwUnprocessableContent`: For unprocessable content (422)
- `throwTooManyRequests`: For rate limit exceeded (429)
- `throwClientClosedRequest`: For client-closed requests

## 9. State Management with Zustand

Zustand stores are organized by feature domain:

```txt
/zustand
  └── /features
       ├── /feed               # Feed-related state
       │    └── feedSlice.ts
       ├── /ui                 # UI-related state
       │    └── modalSlice.ts
       └── /track              # Tracking related state
            ├── paginateSlice.ts
            └── trackedJobSlice.ts
```

**Zustand Slice Pattern:**

```typescript
// File: /zustand/features/ui/modalSlice.ts
import { create } from 'zustand';

type ModalType = 'createFeedPost' | 'updateFeedPost' | null;

interface ModalState {
  activeModal: ModalType;
  setActiveModal: (modal: ModalType) => void;
}

export const modalSlice = create<ModalState>((set) => ({
  activeModal: null,
  setActiveModal: (modal) => set({ activeModal: modal }),
}));
```

**Zustand Persistence:**

By default, state is not persisted. When persistence is explicitly required:

```typescript
// File: /zustand/features/settings/settingsSlice.ts
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

interface SettingsState {
  theme: 'light' | 'dark' | 'system';
  setTheme: (theme: 'light' | 'dark' | 'system') => void;
  // Other settings
}

export const useSettingsStore = create<SettingsState>()(
  persist(
    (set) => ({
      theme: 'system',
      setTheme: (theme) => set({ theme }),
      // Other actions
    }),
    {
      name: 'settings-storage', // Storage key
      storage: typeof window !== 'undefined' ? window.localStorage : undefined,
    }
  )
);
```

## 10. Database Operations Pattern

Prisma operations follow consistent patterns, including transactions for atomic operations:

```typescript
// Single operation
const result = await ctx.db.post.findUnique({
  where: { id },
  include: { author: true },
});

// Transaction for related operations
await ctx.db.$transaction(async (tx) => {
  // Create the main entity
  const newComment = await tx.comment.create({
    data: { text, postId, authorId: userId },
  });

  // Update related statistics
  await tx.postInteractionStats.upsert({
    where: { postId },
    update: { commentsCount: { increment: 1 } },
    create: { postId, commentsCount: 1 },
  });

  return newComment;
});
```

## 11. Modal Organization

Modals are centrally registered and organized by feature domain:

```txt
/modals
  ├── /index.tsx               # Central registry for all modals
  ├── /modal-layout.tsx        # Shared modal layout component
  └── /feature                 # Feature-specific modals
       └── /modal-name
            ├── index.tsx      # Modal container component
            └── modal-name.form.tsx  # Form component
```

**Modal Registry Pattern (`/modals/index.tsx`):**

```typescript
// File: /modals/index.tsx
'use client';

import SuspenseWrapper from '@/components/suspense-wrapper';
import { DialogDrawer } from '@/components/ui/dialog-drawer';
import { modalSlice } from '@/zustand/features/ui/modalSlice';
import { lazy } from 'react';

// Modal definition type for better type safety and organization
interface ModalDefinition {
  Component: React.LazyExoticComponent<React.FC>;
}

// Define all modals in a single object for easier maintenance
const MODALS = {
  DeleteAccount: {
    Component: lazy(() => import('@/modals/user/delete-account')),
  },
  CreateFeedPost: {
    Component: lazy(() => import('@/modals/feed/create-feed-post')),
  },
  // Additional modals
} satisfies Record<string, ModalDefinition>;

// Automatically derive modal keys from the MODALS object
type ModalKeys = keyof typeof MODALS;

const Modals = () => {
  const { activeModal, setActiveModal } = modalSlice();

  // Type guard to ensure activeModal is a valid key
  const isValidModal = (modal: string | null): modal is ModalKeys => {
    return !!modal && modal in MODALS;
  };

  // Get the current modal component safely
  const getCurrentModal = () => {
    if (!activeModal || !isValidModal(activeModal)) return null;

    const { Component } = MODALS[activeModal];
    return <Component />;
  };

  return (
    <DialogDrawer
      className='w-full p-4'
      showModal={!!activeModal}
      setShowModal={() => setActiveModal(null)}
    >
      <SuspenseWrapper>{getCurrentModal()}</SuspenseWrapper>
    </DialogDrawer>
  );
};

export default Modals;
```

## 12. Form Validation with Zod

Validation schemas should follow this structure:

```txt
/lib
  └── /validators
       └── /feed
            └── posts.z.ts
```

**Validation Schema Pattern:**

```typescript
// File: /lib/validators/feed/posts.z.ts
import { z } from 'zod';
import { PostCategory, Visibility } from '@prisma/client';

export const CreatePostFormSchema = z.object({
  text: z.string().min(1, 'Post text is required'),
  visibility: z.nativeEnum(Visibility),
  category: z.nativeEnum(PostCategory),
});
```

## 13. File Naming Conventions

| Type                | Convention                 | Example                           |
|---------------------|----------------------------|-----------------------------------|
| React Components    | kebab-case.tsx             | `profile-card.tsx`                |
| Pages               | kebab-case/entry.tsx       | `job-search/entry.tsx`            |
| Forms               | kebab-case.form.tsx        | `create-feed-post.form.tsx`       |
| Hooks               | useKebabCase.ts            | `useFormSubmit.ts`                |
| Utilities           | kebab-case.ts              | `date-utils.ts`                   |
| Zustand Slices      | camelCaseSlice.ts          | `modalSlice.ts`                   |
| Type Definitions    | kebab-case.types.ts        | `user-profile.types.ts`           |
| tRPC Routers        | kebab-case.ts              | `post.ts`, `comments.ts`          |
| Unit/Integration Tests | [feature].test.tsx      | `button.test.tsx`                 |
| Snapshot Tests      | snapshot.tsx               | `snapshot.tsx`                    |
| Test Directories    | Matches source structure   | `__tests__/components/ui`         |
| Snapshot Directories| _snapshots_                | `__tests__/components/ui/_snapshots_` |

## 14. Component Implementation Guidelines

### Server vs. Client Components

- Use server components (no 'use client' directive) for:
  - Data fetching
  - SEO-critical content
  - Static content rendering

- Use client components ('use client' directive) for:
  - Interactive UI elements
  - Form components
  - Components using React hooks

### Form Implementation Pattern

```tsx
<FormField
  control={form.control}
  name='fieldName'
  render={({ field }) => (
    <FormItem className='...'>
      <FormLabel id='unique-id'>Field Label</FormLabel>
      <FormControl>
        <Input
          aria-labelledby='unique-id'
          {...field}
          placeholder='...'
          disabled={isPending}
        />
      </FormControl>
      <FormMessage>{form.formState.errors.fieldName?.message}</FormMessage>
    </FormItem>
  )}
/>
```

## 15. Feature Development Workflow

The development workflow integrates test-driven development principles with our centralized testing strategy:

### 1. Planning Phase

- Define feature requirements and acceptance criteria
- Identify necessary components, data structures, and API endpoints
- Plan the testing strategy for each component

### 2. Testing Phase

- Write tests in the `__tests__` directory mirroring the feature's structure
- Start with unit and integration tests for critical functionality
- Include snapshot tests for UI components
- Add tests for edge cases and error scenarios

### 3. Implementation Phase

- Develop components and API endpoints to satisfy the tests
- Implement business logic and UI interactions
- Keep code modular and maintainable
- Run tests continuously to ensure they pass

### 4. Review Phase

- Perform code review to ensure adherence to project standards
- Verify test coverage is adequate
- Check snapshot tests for expected UI rendering
- Validate against acceptance criteria

### 5. Finalization Phase

- Refactor code for clarity and optimization
- Update snapshots if UI changes are finalized
- Document any key implementation details
- Merge the feature into the main codebase

## 16. Code Organization Principles

1. **Test-First Development**: Write tests before implementing features
2. **Feature-Driven Organization**: Organize code and tests by feature
3. **Separation of Concerns**: Split data fetching, rendering, and state management
4. **Centralized Testing**: Maintain all tests in the `__tests__` directory
5. **Snapshot Testing**: Capture and verify UI rendering with snapshots
6. **Consistency**: Follow established naming patterns and directory structures

## 17. File Location Decision Guide

When adding new files to your project, use these guidelines:

1. **Is it a test?** → Place in `__tests__` directory mirroring the feature structure
   - Unit/integration tests: Use `.test.tsx` suffix
   - Snapshot tests: Use `snapshot.tsx` filename

2. **Is it a page?** → Place in `/pages/(route-group)/feature/`
   - Entry file: `entry.tsx`
   - Render file: `render.tsx`

3. **Is it a modal?** → Place in `/modals/feature/modal-name/`
   - Modal container: `index.tsx`
   - Form component: `[modal-name].form.tsx`

4. **Is it a reusable UI component?** → Place in `/ui/`

5. **Is it a tRPC router?** → Place in `/server/api/routers/feature/`

6. **Is it a state slice?** → Place in `/zustand/features/domain/`

7. **Is it a form?** → Use `.form.tsx` suffix in the appropriate feature directory

8. **Is it a validation schema?** → Place in `/lib/validators/feature/` using `.z.ts` suffix

9. **Is it a type definition?** → Use `.types.ts` suffix in the appropriate feature directory

## 18. Pagination Pattern

For cursor-based pagination with tRPC, follow this pattern:

```typescript
// Schema definition
export const TrackedJobCursorPaginationSchema = z.object({
  take: z.number().min(1).max(100).default(10),
  skip: z.number().optional(),
  orderBy: z.enum(['createdAt', 'updatedAt']).default('updatedAt'),
  companyInputFilter: z.string().optional(),
});

// tRPC procedure
const getTrackedJobs = protectedProcedure
  .input(TrackedJobCursorPaginationSchema)
  .query(async ({ ctx, input }) => {
    const { take, orderBy, skip, companyInputFilter } = input;
    const userId = ctx.session?.user?.id;
    const validatedTake = Math.min(take, 100); // Limit maximum items

    // Query implementation
    const items = await ctx.db.entity.findMany({
      take: validatedTake + 1, // Get one extra to check if more exist
      skip,
      // ... other options
    });

    const hasNextPage = items.length > validatedTake;
    const formattedItems = items.slice(0, validatedTake);

    return {
      items: formattedItems,
      hasNextPage,
    };
  });
```

## 19. Authentication & Authorization Pattern

Protect routes using tRPC procedures:

```typescript
// Public procedure - accessible to all
const publicProcedure = publicProcedure
  .input(InputSchema)
  .query(async ({ ctx, input }) => {
    // Implementation
  });

// Protected procedure - requires authentication
const protectedProcedure = protectedProcedure
  .input(InputSchema)
  .mutation(async ({ ctx, input }) => {
    const userId = ctx.session.user.id;

    // Implementation with user context
  });

// Owner check pattern
if (entity.authorId !== userId) {
  throwForbidden('You are not allowed to modify this resource');
}
```
