# Next.js Project Architecture & Best Practices Guide

This comprehensive guide provides detailed instructions for maintaining a consistent, scalable architecture in your Next.js application. It incorporates shadcn/ui components, tRPC, Zustand state management, and Prisma for data access.

## 1. Project Root Structure

```txt
/src
  ├── /app                     # App Router components
  ├── /components              # Reusable UI components
  ├── /pages                   # Organized page components
  │    ├── /(candidate)        # Route group for candidate features
  │    ├── /settings           # Settings pages
  │    └── /u                  # User-related pages
  ├── /modals                  # Modal components by feature
  ├── /lib                     # Core utilities and validators
  ├── /server                  # Server-side code
  │    ├── /api                # API layer
  │    │    ├── /routers       # tRPC router definitions
  │    │    └── errors.ts      # Error handling utilities
  ├── /ui                      # UI components (shadcn/ui)
  ├── /zustand                 # State management
  │    └── /features           # Feature-specific state slices
  ├── /hooks                   # Custom React hooks
  ├── /prisma                  # Database schema
  ├── /styles                  # Global styles
  ├── /trpc                    # tRPC client setup
  └── /config                  # Configuration files
```

## 2. Test-Driven Development Workflow

This project follows a test-driven development (TDD) approach for all feature work:

### For New Features

1. **Write Tests First**: Begin by creating comprehensive tests that define the expected behavior of the feature.
2. **Implement the Feature**: Develop the feature to make the tests pass.
3. **Refactor**: Improve the implementation while ensuring tests continue to pass.

### For Existing Features

1. **Check Existing Tests**: Review current test coverage for the feature.
2. **Update Tests**: Modify tests to reflect new requirements or behaviors.
3. **Add Missing Tests**: Create new tests for uncovered scenarios.
4. **Implement Changes**: Modify the feature guided by the updated tests.

### TDD Cycle

1. **Red**: Write a failing test that defines the required functionality.
2. **Green**: Implement the minimum code necessary to make the test pass.
3. **Refactor**: Clean up the implementation while maintaining passing tests.

Tests should be comprehensive, covering:

- Component rendering
- User interactions
- Edge cases
- Error handling
- Integration with other components

## 3. Page Structure Conventions

Pages are organized by feature and follow a consistent pattern with entry and render files:

```txt
/pages
  └── /(route-group)
       └── /feature-name
            ├── entry.tsx       # Entry point with data fetching
            ├── entry.test.tsx  # Tests for entry component
            ├── render.tsx      # Component rendering logic
            └── render.test.tsx # Tests for render component
```

**Entry File Pattern (`entry.tsx`):**

- Handles data fetching and initial state
- Sets up error boundaries
- Provides data to the render component

**Render File Pattern (`render.tsx`):**

- Pure presentation logic
- Receives props from entry component
- Focused on rendering UI elements

## 4. Form Component Convention

Forms are organized by feature with a `.form.tsx` suffix and accompanied by tests:

```txt
/pages/(candidate)/profile/sections/general-info/
  ├── profile-general-info.form.tsx
  └── profile-general-info.form.test.tsx
```

**Form Component Structure:**

```typescript
// File: /modals/feed/create-feed-post/create-feed-post.form.tsx
'use client';

// 1. Imports
import { Form, FormField, ... } from '@/components/ui/form';
import { CreatePostFormSchema } from '@/lib/validators/feed/posts.z';
import { api } from '@/trpc/react';
import { feedSlice } from '@/zustand/features/feed/feedSlice';
import { modalSlice } from '@/zustand/features/ui/modalSlice';

// 2. Component
const CreateFeedPostForm = () => {
  // State management
  const { setActiveModal } = modalSlice();
  const { category } = feedSlice();

  // Form setup with react-hook-form and zod
  const form = useForm<z.infer<typeof CreatePostFormSchema>>({
    resolver: zodResolver(CreatePostFormSchema),
    defaultValues: {
      // Default values
    },
  });

  // API mutation
  const { isPending, mutateAsync } = api.feed.postRouter.createPost.useMutation();

  // Submit handler
  const onSubmit = async (values: z.infer<typeof CreatePostFormSchema>) => {
    try {
      // Form submission logic
    } catch (error) {
      // Error handling
    }
  };

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="...">
        {/* Form fields */}
      </form>
    </Form>
  );
};

export default CreateFeedPostForm;
```

## 5. API Layer with tRPC

The tRPC implementation follows a hierarchical structure under `/server/api/routers/`:

```txt
/server
  └── /api
       ├── /routers
       │    ├── /feed
       │    │    ├── index.ts          # Combines feed routers
       │    │    ├── post.ts           # Post-related routes
       │    │    ├── post.test.ts      # Tests for post routes
       │    │    ├── comments.ts       # Comment-related routes
       │    │    └── comments.test.ts  # Tests for comment routes
       │    └── index.ts               # Root router
       ├── /errors.ts                  # Error handling utilities
       ├── /trpc.ts                    # tRPC configuration
       └── /db.ts                      # Database client
```

**Router Structure Pattern:**

```typescript
// File: /server/api/routers/feed/index.ts
import { createTRPCRouter } from '../../trpc';
import { commentsRouter } from './comments';
import { postRouter } from './post';

export const feedRouter = createTRPCRouter({
  postRouter,
  commentsRouter,
});
```

**Individual Router Pattern:**

```typescript
// File: /server/api/routers/feed/post.ts
import {
  createTRPCRouter,
  protectedProcedure,
  publicProcedure,
} from '../../trpc';
import { throwInternalError, throwNotFound } from '../../errors';

// Define procedures
const createPost = protectedProcedure
  .input(CreatePostFormSchema)
  .mutation(async ({ ctx, input }) => {
    try {
      // Implementation
    } catch (error) {
      process.env.NODE_ENV === 'development' &&
        console.error('Error creating post:', error);
      throwInternalError('Error creating post');
    }
  });

// Export the combined router
export const postRouter = createTRPCRouter({
  createPost,
  // Additional procedures
});
```

## 6. Error Handling Pattern

Standardized error handling with specialized error functions:

```typescript
// In your API routes
try {
  // Operation logic
} catch (error) {
  process.env.NODE_ENV.NODE_ENV === 'development' &&
    console.error('Error operation description:', error);
  throwInternalError('Error message for user');
}
```

**Error Types:**

- `throwInternalError`: For server errors (500)
- `throwNotFound`: For resource not found errors (404)
- `throwForbidden`: For permission errors (403)
- `throwUnauthorized`: For authentication errors (401)
- `throwBadRequest`: For invalid request errors (400)
- `throwConflict`: For resource conflict errors (409)
- `throwParseError`: For request parsing errors
- `throwMethodNotSupported`: For unsupported HTTP methods (405)
- `throwTimeout`: For request timeout errors (408)
- `throwPreconditionFailed`: For precondition failures (412)
- `throwPayloadTooLarge`: For request entity too large (413)
- `throwUnsupportedMediaType`: For unsupported media types (415)
- `throwUnprocessableContent`: For unprocessable content (422)
- `throwTooManyRequests`: For rate limit exceeded (429)
- `throwClientClosedRequest`: For client-closed requests

## 7. State Management with Zustand

Zustand stores are organized by feature domain:

```txt
/zustand
  └── /features
       ├── /feed               # Feed-related state
       │    ├── feedSlice.ts
       │    └── feedSlice.test.ts
       ├── /ui                 # UI-related state
       │    ├── modalSlice.ts
       │    └── modalSlice.test.ts
       └── /track              # Tracking related state
            ├── paginateSlice.ts
            └── paginateSlice.test.ts
```

**Zustand Slice Pattern:**

```typescript
// File: /zustand/features/ui/modalSlice.ts
import { create } from 'zustand';

type ModalType = 'createFeedPost' | 'updateFeedPost' | null;

interface ModalState {
  activeModal: ModalType;
  setActiveModal: (modal: ModalType) => void;
}

export const modalSlice = create<ModalState>((set) => ({
  activeModal: null,
  setActiveModal: (modal) => set({ activeModal: modal }),
}));
```

**Zustand Persistence:**

By default, state is not persisted. When persistence is explicitly required:

```typescript
// File: /zustand/features/settings/settingsSlice.ts
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

interface SettingsState {
  theme: 'light' | 'dark' | 'system';
  setTheme: (theme: 'light' | 'dark' | 'system') => void;
  // Other settings
}

export const useSettingsStore = create<SettingsState>()(
  persist(
    (set) => ({
      theme: 'system',
      setTheme: (theme) => set({ theme }),
      // Other actions
    }),
    {
      name: 'settings-storage', // Storage key
      storage: typeof window !== 'undefined' ? window.localStorage : undefined,
    }
  )
);
```

## 8. Testing Strategy

Tests are co-located with the components they test, following a component-driven approach:

```txt
/components
  └── /ui
       └── /button
            ├── button.tsx
            └── button.test.tsx
```

**Component Test Pattern:**

```typescript
// File: /components/ui/button/button.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import { Button } from './button';

describe('Button', () => {
  it('renders correctly', () => {
    render(<Button>Click me</Button>);
    expect(screen.getByRole('button', { name: /click me/i })).toBeInTheDocument();
  });

  it('calls onClick handler when clicked', () => {
    const onClickMock = jest.fn();
    render(<Button onClick={onClickMock}>Click me</Button>);
    fireEvent.click(screen.getByRole('button', { name: /click me/i }));
    expect(onClickMock).toHaveBeenCalledTimes(1);
  });

  it('applies variant classes correctly', () => {
    render(<Button variant="destructive">Delete</Button>);
    const button = screen.getByRole('button', { name: /delete/i });
    expect(button).toHaveClass('bg-destructive');
  });

  it('is disabled when disabled prop is true', () => {
    render(<Button disabled>Disabled</Button>);
    expect(screen.getByRole('button', { name: /disabled/i })).toBeDisabled();
  });
});
```

**Form Component Test Pattern:**

```typescript
// File: /modals/feed/create-feed-post/create-feed-post.form.test.tsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { CreateFeedPostForm } from './create-feed-post.form';
import { api } from '@/trpc/react';

// Mock the tRPC calls
jest.mock('@/trpc/react', () => ({
  api: {
    feed: {
      postRouter: {
        createPost: {
          useMutation: jest.fn().mockReturnValue({
            isPending: false,
            mutateAsync: jest.fn().mockResolvedValue({ success: true }),
          }),
        },
      },
    },
  },
}));

// Mock the Zustand store
jest.mock('@/zustand/features/feed/feedSlice', () => ({
  feedSlice: jest.fn().mockReturnValue({
    category: 'GENERAL',
  }),
}));

jest.mock('@/zustand/features/ui/modalSlice', () => ({
  modalSlice: jest.fn().mockReturnValue({
    setActiveModal: jest.fn(),
  }),
}));

describe('CreateFeedPostForm', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('renders the form correctly', () => {
    render(<CreateFeedPostForm />);
    expect(screen.getByLabelText(/text/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/category/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/visibility/i)).toBeInTheDocument();
    expect(screen.getByRole('button', { name: /create post/i })).toBeInTheDocument();
  });

  it('validates form inputs', async () => {
    render(<CreateFeedPostForm />);

    // Submit empty form
    fireEvent.click(screen.getByRole('button', { name: /create post/i }));

    // Check for validation errors
    await waitFor(() => {
      expect(screen.getByText(/post text is required/i)).toBeInTheDocument();
    });
  });

  it('submits the form with valid data', async () => {
    const user = userEvent.setup();
    const mutateAsyncMock = jest.fn().mockResolvedValue({ success: true, message: 'Post created!' });

    (api.feed.postRouter.createPost.useMutation as jest.Mock).mockReturnValue({
      isPending: false,
      mutateAsync: mutateAsyncMock,
    });

    render(<CreateFeedPostForm />);

    // Fill form fields
    await user.type(screen.getByLabelText(/text/i), 'Test post content');

    // Submit form
    await user.click(screen.getByRole('button', { name: /create post/i }));

    // Verify submission
    await waitFor(() => {
      expect(mutateAsyncMock).toHaveBeenCalledWith({
        text: 'Test post content',
        visibility: 'PUBLIC',
        category: 'GENERAL',
      });
    });
  });
});
```

**tRPC Router Test Pattern:**

```typescript
// File: /server/api/routers/feed/post.test.ts
import { createInnerTRPCContext } from '../../trpc';
import { appRouter } from '../';
import { mockDeep } from 'jest-mock-extended';
import { PrismaClient } from '@prisma/client';
import { Session } from 'next-auth';

// Create mocks
const prismaMock = mockDeep<PrismaClient>();
const sessionMock = {
  user: { id: 'user-123', name: 'Test User' },
  expires: new Date().toISOString(),
} as Session;

// Create test caller
const createCaller = (session: Session | null = null) => {
  const ctx = createInnerTRPCContext({
    session,
    db: prismaMock,
  });
  return appRouter.createCaller(ctx);
};

describe('Post Router', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('createPost', () => {
    it('creates a post successfully', async () => {
      // Setup mocks
      prismaMock.post.create.mockResolvedValueOnce({
        id: 'post-123',
        authorId: 'user-123',
        text: 'Test post',
        visibility: 'PUBLIC',
        category: 'GENERAL',
        createdAt: new Date(),
        updatedAt: new Date(),
      });

      const caller = createCaller(sessionMock);

      // Call the procedure
      const result = await caller.feed.postRouter.createPost({
        text: 'Test post',
        visibility: 'PUBLIC',
        category: 'GENERAL',
      });

      // Assertions
      expect(prismaMock.post.create).toHaveBeenCalledWith({
        data: {
          authorId: 'user-123',
          text: 'Test post',
          visibility: 'PUBLIC',
          category: 'GENERAL',
        },
        include: expect.any(Object),
      });

      expect(result).toEqual({
        success: true,
        message: 'Post created!',
        data: expect.objectContaining({
          id: 'post-123',
          text: 'Test post',
        }),
      });
    });

    it('throws an error for unauthenticated users', async () => {
      const caller = createCaller(null);

      // Call the procedure and expect it to throw
      await expect(caller.feed.postRouter.createPost({
        text: 'Test post',
        visibility: 'PUBLIC',
        category: 'GENERAL',
      })).rejects.toThrow('UNAUTHORIZED');
    });
  });
});
```

## 9. Database Operations Pattern

Prisma operations follow consistent patterns, including transactions for atomic operations:

```typescript
// Single operation
const result = await ctx.db.post.findUnique({
  where: { id },
  include: { author: true },
});

// Transaction for related operations
await ctx.db.$transaction(async (tx) => {
  // Create the main entity
  const newComment = await tx.comment.create({
    data: { text, postId, authorId: userId },
  });

  // Update related statistics
  await tx.postInteractionStats.upsert({
    where: { postId },
    update: { commentsCount: { increment: 1 } },
    create: { postId, commentsCount: 1 },
  });

  return newComment;
});
```

## 10. Modal Organization

Modals are centrally registered and organized by feature domain:

```txt
/modals
  ├── /index.tsx               # Central registry for all modals
  ├── /modal-layout.tsx        # Shared modal layout component
  └── /feature                 # Feature-specific modals
       └── /modal-name
            ├── index.tsx      # Modal container component
            ├── index.test.tsx # Tests for modal container
            ├── modal-name.form.tsx  # Form component
            └── modal-name.form.test.tsx  # Tests for form component
```

**Modal Registry Pattern (`/modals/index.tsx`):**

```typescript
// File: /modals/index.tsx
'use client';

import SuspenseWrapper from '@/components/suspense-wrapper';
import { DialogDrawer } from '@/components/ui/dialog-drawer';
import { modalSlice } from '@/zustand/features/ui/modalSlice';
import { lazy } from 'react';

// Modal definition type for better type safety and organization
interface ModalDefinition {
  Component: React.LazyExoticComponent<React.FC>;
}

// Define all modals in a single object for easier maintenance
const MODALS = {
  DeleteAccount: {
    Component: lazy(() => import('@/modals/user/delete-account')),
  },
  CreateFeedPost: {
    Component: lazy(() => import('@/modals/feed/create-feed-post')),
  },
  ReportFeedPost: {
    Component: lazy(() => import('@/modals/feed/report-feed-post')),
  },
  UpdateFeedPost: {
    Component: lazy(() => import('@/modals/feed/update-feed-post')),
  },
  CreateTrackJob: {
    Component: lazy(() => import('@/modals/track/create-track-job')),
  },
} satisfies Record<string, ModalDefinition>;

// Automatically derive modal keys from the MODALS object
type ModalKeys = keyof typeof MODALS;

const Modals = () => {
  const { activeModal, setActiveModal } = modalSlice();

  // Type guard to ensure activeModal is a valid key
  const isValidModal = (modal: string | null): modal is ModalKeys => {
    return !!modal && modal in MODALS;
  };

  // Get the current modal component safely
  const getCurrentModal = () => {
    if (!activeModal || !isValidModal(activeModal)) return null;

    const { Component } = MODALS[activeModal];
    return <Component />;
  };

  return (
    <DialogDrawer
      className='w-full p-4'
      showModal={!!activeModal}
      setShowModal={() => setActiveModal(null)}
    >
      <SuspenseWrapper>{getCurrentModal()}</SuspenseWrapper>
    </DialogDrawer>
  );
};

export default Modals;
```

## 11. Form Validation with Zod

Validation schemas should follow this structure:

```txt
/lib
  └── /validators
       └── /feed
            ├── posts.z.ts
            └── posts.z.test.ts
```

**Validation Schema Pattern:**

```typescript
// File: /lib/validators/feed/posts.z.ts
import { z } from 'zod';
import { PostCategory, Visibility } from '@prisma/client';

export const CreatePostFormSchema = z.object({
  text: z.string().min(1, 'Post text is required'),
  visibility: z.nativeEnum(Visibility),
  category: z.nativeEnum(PostCategory),
});
```

## 12. File Naming Conventions

| Type             | Convention           | Example                     |
| ---------------- | -------------------- | --------------------------- |
| React Components | kebab-case.tsx       | `profile-card.tsx`          |
| Pages            | kebab-case/entry.tsx | `job-search/entry.tsx`      |
| Forms            | kebab-case.form.tsx  | `create-feed-post.form.tsx` |
| Hooks            | useKebabCase.ts      | `useFormSubmit.ts`          |
| Utilities        | kebab-case.ts        | `date-utils.ts`             |
| Zustand Slices   | camelCaseSlice.ts    | `modalSlice.ts`             |
| Type Definitions | kebab-case.types.ts  | `user-profile.types.ts`     |
| tRPC Routers     | kebab-case.ts        | `post.ts`, `comments.ts`    |
| Test Files       | kebab-case.test.tsx  | `profile-card.test.tsx`     |

## 13. Component Implementation Guidelines

### Server vs. Client Components

- Use server components (no 'use client' directive) for data fetching and static content rendering
- Use client components ('use client' directive) for interactive UI elements and forms

### Form Implementation

Implement form fields following this pattern:

```tsx
<FormField
  control={form.control}
  name='fieldName'
  render={({ field }) => (
    <FormItem className='...'>
      <FormLabel id='unique-id'>Field Label</FormLabel>
      <FormControl>
        <Input
          aria-labelledby='unique-id'
          {...field}
          placeholder='...'
          disabled={isPending}
        />
      </FormControl>
      <FormMessage>{form.formState.errors.fieldName?.message}</FormMessage>
    </FormItem>
  )}
/>
```

## 14. Feature Development Workflow

The development workflow integrates test-driven development principles with our project architecture:

### 1. Planning Phase

- Define feature requirements and acceptance criteria
- Identify necessary components, data structures, and API endpoints
- Plan the testing strategy for each component

### 2. Testing Phase

- Write tests for all components and API endpoints
- Start with the most critical functionality
- Include tests for edge cases and error scenarios

### 3. Implementation Phase

- Develop components and API endpoints to satisfy the tests
- Implement business logic and UI interactions
- Keep code modular and maintainable
- Ensure tests pass before proceeding

### 4. Review Phase

- Perform code review to ensure adherence to project standards
- Verify test coverage is adequate
- Check for potential performance issues
- Validate against acceptance criteria

### 5. Finalization Phase

- Refactor code for clarity and optimization
- Document any key implementation details
- Merge the feature into the main codebase

## 15. Code Organization Principles

1. **Test-First Development**: Write tests before implementing features
2. **Co-location**: Keep related files together, including tests
3. **Feature-driven**: Organize by feature first, then by type
4. **Separation of concerns**: Split data fetching, rendering, and state management
5. **Reusability**: Extract common patterns into shared components
6. **Consistency**: Follow established naming patterns and directory structures

## 16. File Location Decision Guide

When adding new files to your project, use these guidelines:

1. **Is it a test for a new feature?** → Write the test first before implementation
2. **Is it a page?** → Place in `/pages/(route-group)/feature/` with tests
3. **Is it a modal?** → Place in `/modals/feature/modal-name/` with tests
4. **Is it a reusable UI component?** → Place in `/ui/` with tests
5. **Is it a tRPC router?** → Place in `/server/api/routers/feature/` with tests
6. **Is it a state slice?** → Place in `/zustand/features/domain/` with tests
7. **Is it a form?** → Use `.form.tsx` suffix with `.form.test.tsx` tests
8. **Is it a validation schema?** → Place in `/lib/validators/feature/` with tests

## 17. Pagination Pattern

For cursor-based pagination with tRPC, follow this pattern:

```typescript
// Schema definition
export const TrackedJobCursorPaginationSchema = z.object({
  take: z.number().min(1).max(100).default(10),
  skip: z.number().optional(),
  orderBy: z.enum(['createdAt', 'updatedAt']).default('updatedAt'),
  companyInputFilter: z.string().optional(),
});

// tRPC procedure
const getTrackedJobs = protectedProcedure
  .input(TrackedJobCursorPaginationSchema)
  .query(async ({ ctx, input }) => {
    const { take, orderBy, skip, companyInputFilter } = input;
    const userId = ctx.session?.user?.id;
    const validatedTake = Math.min(take, 100); // Limit maximum items

    // Query implementation
    const items = await ctx.db.entity.findMany({
      take: validatedTake + 1, // Get one extra to check if more exist
      skip,
      // ... other options
    });

    const hasNextPage = items.length > validatedTake;
    const formattedItems = items.slice(0, validatedTake);

    return {
      items: formattedItems,
      hasNextPage,
    };
  });
```

## 18. Authentication & Authorization Pattern

Protect routes using tRPC procedures:

```typescript
// Public procedure - accessible to all
const publicProcedure = publicProcedure
  .input(InputSchema)
  .query(async ({ ctx, input }) => {
    // Implementation
  });

// Protected procedure - requires authentication
const protectedProcedure = protectedProcedure
  .input(InputSchema)
  .mutation(async ({ ctx, input }) => {
    const userId = ctx.session.user.id;

    // Implementation with user context
  });

// Owner check pattern
if (entity.authorId !== userId) {
  throwForbidden('You are not allowed to modify this resource');
}
```

